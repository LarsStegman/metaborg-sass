module analysis/sass

imports
  analysis/-

signature 
  name resolution
    constructors
      IntT    : -> Type
      FloatT  : -> Type
      BoolT   : -> Type
      StringT : -> Type
      NullT   : -> Type
      ColourT : -> Type
      LengthT : Type * String -> Type // The exp type and the unit
      BinExpT : Type * Type * Type -> Type // Result num type * lhsT * rhsT
      
      
      CSSAble : -> CSSAble
      
      IntTC    : -> CSSType
      FloatTC  : -> CSSType
      BoolTC   : -> CSSType
      StringTC : -> CSSType
      ColourTC : -> CSSType
      LengthTC : -> CSSType
      
    namespaces
      Var
      Function
      Mixin
   
  functions
    typeForCSSExport: Type -> CSSType {
      IntT()      -> IntTC(),
      FloatT()    -> FloatTC(),
      BoolT()     -> BoolTC(),
      StringT()   -> StringTC(),
      ColourT()   -> ColourTC(),
      LengthT(_, _)  -> LengthTC()
    }
    
    typeForAddition: (Type * Type) -> Type {
      (IntT(), IntT())          -> IntT(),
      (FloatT(), FloatT())      -> FloatT(),
      (StringT(), StringT())    -> StringT(),
      (ColourT(), ColourT())    -> ColourT(),
      
      (LengthT(IntT(), u), LengthT(IntT(), u))      -> LengthT(IntT(), u),
      (LengthT(FloatT(), u), LengthT(FloatT(), u))  -> LengthT(FloatT(), u),
      (LengthT(IntT(), u), LengthT(FloatT(), u))    -> LengthT(FloatT(), u),
      (LengthT(FloatT(), u), LengthT(IntT(), u))    -> LengthT(FloatT(), u),
      
      (IntT(), FloatT()) -> FloatT(),
      (FloatT(), IntT()) -> FloatT(),
      
      (_, StringT()) -> StringT(),
      (StringT(), _) -> StringT()
    }
    
    typeForSubtraction: (Type * Type) -> Type {
      (IntT(), IntT())          -> IntT(),
      (FloatT(), FloatT())      -> FloatT(),
      (ColourT(), ColourT())    -> ColourT(),
      
      (LengthT(IntT(), u), LengthT(IntT(), u))      -> LengthT(IntT(), u),
      (LengthT(FloatT(), u), LengthT(FloatT(), u))  -> LengthT(FloatT(), u),
      (LengthT(IntT(), u), LengthT(FloatT(), u))    -> LengthT(FloatT(), u),
      (LengthT(FloatT(), u), LengthT(IntT(), u))    -> LengthT(FloatT(), u),

      (IntT(), FloatT()) -> FloatT(),
      (FloatT(), IntT()) -> FloatT()
    }
    
    typeForMultiplication: (Type * Type) -> Type {
      (IntT(), IntT())          -> IntT(),
      (FloatT(), FloatT())      -> FloatT(),
      (ColourT(), ColourT())    -> ColourT(),
      
      (IntT(), FloatT()) -> FloatT(),
      (FloatT(), IntT()) -> FloatT(),
      
      
      (IntT(), LengthT(IntT(), u))      -> LengthT(IntT(), u),
      (LengthT(IntT(), u), IntT())      -> LengthT(IntT(), u),
      (IntT(), LengthT(FloatT(), u))    -> LengthT(FloatT(), u),
      (LengthT(FloatT(), u), IntT())    -> LengthT(FloatT(), u),
      
      (FloatT(), LengthT(FloatT(), u))  -> LengthT(FloatT(), u),
      (LengthT(FloatT(), u), FloatT())  -> LengthT(FloatT(), u),
      (FloatT(), LengthT(IntT(), u))    -> LengthT(FloatT(), u),
      (LengthT(IntT(), u), FloatT())    -> LengthT(FloatT(), u),
      
      
      (IntT(), ColourT())     -> ColourT(),
      (FloatT(), ColourT())   -> ColourT(),
      (ColourT(), IntT())     -> ColourT(),
      (ColourT(), FloatT())   -> ColourT(),
      
      (LengthT(IntT(), l), LengthT(IntT(), r))      -> BinExpT(IntT(), LengthT(IntT(), l), LengthT(IntT(), r)),
      (LengthT(FloatT(), l), LengthT(IntT(), r))    -> BinExpT(FloatT(), LengthT(FloatT(), l), LengthT(IntT(), r)),
      (LengthT(IntT(), l), LengthT(FloatT(), r))    -> BinExpT(FloatT(), LengthT(IntT(), l), LengthT(FloatT(), r)),
      (LengthT(FloatT(), l), LengthT(FloatT(), r))  -> BinExpT(FloatT(), LengthT(FloatT(), l), LengthT(FloatT(), r)),
      
      (BinExpT(IntT(), x, y), LengthT(IntT(), u))     -> BinExpT(IntT(), BinExpT(IntT(), x, y), LengthT(IntT(), u)),
      (BinExpT(FloatT(), x, y), LengthT(IntT(), u))   -> BinExpT(FloatT(), BinExpT(FloatT(), x, y), LengthT(IntT(), u)),
      (BinExpT(IntT(), x, y), LengthT(FloatT(), u))   -> BinExpT(FloatT(), BinExpT(IntT(), x, y), LengthT(FloatT(), u)),
      (BinExpT(FloatT(), x, y), LengthT(FloatT(), u)) -> BinExpT(FloatT(), BinExpT(FloatT(), x, y), LengthT(FloatT(), u))
    }
    
    typeForDivision: (Type * Type) -> Type {
      (BinExpT(_, LengthT(_, u), r), LengthT(_, u)) -> r,
      (BinExpT(_, l, LengthT(_, u)), LengthT(_, u)) -> l
    }

name resolution
  labels
    G // Global scope
    P

  order 
    D < G,
    D < P,
    G < P   

  well-formedness
    P* G*

relations 
  
  /**
   *  Whether a type is coerceable to another, e.g. number to string
   */
  reflexive,    anti-symmetric, transitive      coerce : Type * Type

  /**
   * Whether a type can be emited to CSS
   */
  reflexive,    symmetric,      transitive      cssable: Type * CSSAble
   
rules
  
  init :=
    FloatTC()  <cssable! CSSAble(),
    IntTC()    <cssable! CSSAble(),
    BoolTC()   <cssable! CSSAble(),
    ColourTC() <cssable! CSSAble(),
    StringTC() <cssable! CSSAble(),
    LengthTC() <cssable! CSSAble(),
    
    FloatT()  <coerce! StringT(),
    NullT()   <coerce! StringT(), // emptystring
    BoolT()   <coerce! StringT(),
    ColourT() <coerce! StringT(),
    IntT()    <coerce! FloatT(),
    
    NullT()   <coerce! BoolT(), // false
    FloatT()  <coerce! BoolT(). // true
  
  [[ Script(items) ]] :=
    new sS, 
    RootScopeIterative[[ items ^ (sS) ]].
 
  RootScopeIterative[[ [] ^ (_) ]].
  ScopeIterative    [[ [] ^ (_, nGS, finalGS) ]] :=
    finalGS -G-> nGS.
    