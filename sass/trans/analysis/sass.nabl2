module analysis/sass

imports
  analysis/-

signature 
  name resolution
    constructors
      IntT    : -> Type
      FloatT  : -> Type
      BoolT   : -> Type
      StringT : -> Type
      NullT   : -> Type
      ColourT : -> Type
      LengthT : String * Int -> Type // Unit * exponent
    
    namespaces
      Var
      Function
      Mixin

name resolution
  labels
    G // Global scope
    P

  order 
    D < G,
    D < P,
    G < P   

  well-formedness
    P* G*

relations
  /**
   *  Whether two types can be added together.
   *  e.g. String + bool is allowed, but bool + bool not
   */
  reflexive,  symmetric,      transitive      addable : Type * Type 
  
  /**
   *  Whether a type is coerceable to another, e.g. number to string
   */
  reflexive,    anti-symmetric, transitive      coerce : Type * Type

rules
  
  init :=
    StringT() <addable! StringT(),
    FloatT()  <addable! FloatT(),
    IntT()    <addable! IntT(),
//    LengthT(_, _) <addable! LengthT(_, _),
    ColourT() <addable! ColourT(),
    
    IntT()    <addable! FloatT(),
    StringT() <addable! IntT(),
    StringT() <addable! NullT(),
//    StringT() <addable! LengthT(_, _),
    StringT() <addable! BoolT(),
    StringT() <addable! ColourT(),
    
    FloatT()  <coerce! StringT(),
    NullT()   <coerce! StringT(), // emptystring
    BoolT()   <coerce! StringT(),
    ColourT() <coerce! StringT(),
    IntT()    <coerce! FloatT(),
//    LengthT(_, _) <coerce! StringT(),
    
    NullT()   <coerce! BoolT(), // false
    FloatT()  <coerce! BoolT(). // true

  [[ Script(items) ]] :=
    new sS, 
    RootScopeIterative[[ items ^ (sS) ]].
 
  RootScopeIterative[[ [] ^ (_) ]].
  ScopeIterative    [[ [] ^ (_, nGS, finalGS) ]] :=
    finalGS -G-> nGS.
    