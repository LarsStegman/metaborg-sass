module evaluate/expression

imports
  nabl2/api
  nabl2shared

imports
  evaluate/evaluate
  evaluate/number
  src-gen/signatures/Expression-sig
  src-gen/signatures/String-sig
  desugar/expression/-
  analysis/sass
  
  evaluate/coerce
  evaluate/interpret/interpret

strategies
  evaluate-exp(|store) = bottomup(try(evaluate-e(|store)))

strategies
  extract: (l, r) -> (<extr> l, <extr> r)
  extract: Length(n, _) -> <extr> n
  extract: Int(f) -> <string-to-int> f
  extract: Float(f) -> <string-to-real> f
  extract: String(s, _) -> s
  extr-f: (l, r) -> (<extr-f> l, <extr-f> r)
  extr-f: f@Float(_) -> <extr> f
  extr-f: Int(f) -> <string-to-real> f
  
  construct-end-type: BinExpT(l, nT, _, _) -> <construct-end-type> (l, nT)
  construct-end-type: (LengthT(None(), u), nT) -> LengthT(nT, u)
  construct-end-type: (LengthT(l, u), nT) -> LengthT(<construct-end-type> (l, nT), u)
  
  extr = try(extract)

  apply-bin(|f) = extr; call(f||); try(intl-float)
  
  wrap-result: (IntT(),   v) -> Int(v)
  wrap-result: (FloatT(), v) -> Float(v)
  wrap-result: (LengthT(eT, u), v) -> Length(<wrap-result> (eT, v), u)
  wrap-result: (StringT(), v) -> String(v, DoubleQuote())
  
  op-to-f: (Add(), IntT()) -> "addi"
  op-to-f: (Sub(), IntT()) -> "subti"
  op-to-f: (Mul(), IntT()) -> "muli"
  op-to-f: (Mod(), IntT()) -> "modi"
  
  op-to-f: (Add(), FloatT()) -> "addr"
  op-to-f: (Sub(), FloatT()) -> "subtr"
  op-to-f: (Mul(), FloatT()) -> "mulr"
  op-to-f: (Div(), _)        -> "divr"
  op-to-f: (Mod(), FloatT()) -> "modr"
  
  op-to-f: (Add(), StringT()) -> "conc-strings"

  extr-math-type: LengthT(e, _) -> <try(extr-math-type)> e  
  extr-math-type: BinExpT(_, t, _, _) -> t
  extr-comp-v:    Length(e, _)  -> <try(extr-comp-v)> e


  exp-t: Int(_) -> IntT()
  exp-t: Float(_) -> FloatT()

/**
 * 
 */
strategies
  truthy = not(?False() <+ ?Null())

/**
 * Variable lookup
 */  
rules
  evaluate-e(|store): VarRef(x) -> e with
    e := <get-var(|store)> x


/** 
 * Logic
 */
rules
  evaluate-e(|store): BinExp(And(), lhs, rhs) -> 
    <?(True(), True()) < !True() + !False()> (lhs, rhs)
  evaluate-e(|store): BinExp(Or(), lhs, rhs) -> 
    <?(True(), _) < !True() + ?(_, True()) < !True() + !False()> (lhs, rhs)
  evaluate-e(|store): UnExp(Not(), e) -> <?True() < !False() + !True()> e


/**
 * Comparison
 */
rules
  evaluate-e(|store): BinExp(Eq(), lhs, rhs) -> // This might not be accurate for number comparisons
    <?(e, e) < !True() + !False()> (<strip-annos> lhs, <strip-annos> rhs)
  evaluate-e(|store): BinExp(Gt(), lhs, rhs) ->  
    <extr-f; gtr < !True() + !False()> (lhs, rhs) 

  
/**
 * Math
 */
rules
//  evaluate-e(|store): e@BinExp(op, lhs, rhs) -> r with 
//    // Get the expression result types
//    a := <nabl2-get-ast-analysis>
//    ; endT  := <nabl2-get-ast-type(|a)> e 
//    ; wrapT := <try(construct-end-type)> endT
//    
//    // Extract the types for the math (sub)expressions,
//    // e.g. LengthT(IntT(), _) -> IntT()
//    ; compExpT  := <try(extr-math-type)> endT
//    ; eLV := <try(extr-comp-v)> lhs
//    ; eRV := <try(extr-comp-v)> rhs
//    
//    // Coerce the expressions to the needed types.
//    ; compLV := <coerce> (eLV, compExpT)
//    ; compRV := <coerce> (eRV, compExpT)
//    
//    // Perform the calculation
//    ; f   := <op-to-f> (op, compExpT)
//    ; f'  := <op-to-f> (op, compLV, compRV)
//    ; v   := <apply-bin(|f)> (compLV, compRV)
//    ; r   := <wrap-result> (wrapT, v)

strategies
  op-to-f: (Add(), IntT(), IntT())  -> "addi"
  op-to-f: (Add(), FloatT(), _)     -> "addr"
  op-to-f: (Add(), _, FloatT())     -> "addr"

rules
  evaluate-e(|store): BinExp(op, lhs, rhs) -> r with
    lT := <exp-t> lhs
    ; rT := <exp-t> rhs
    
    ; f := <op-to-f> (op, lT, rT)
    ; r := <apply-bin(|f)> (lhs, rhs)
