module evaluate/expression

imports
  nabl2/api
  nabl2shared

imports
  evaluate/evaluate
  evaluate/number
  src-gen/signatures/Expression-sig
  src-gen/signatures/String-sig
  desugar/expression/-
  analysis/sass
  
  evaluate/coerce
  evaluate/interpret/interpret

strategies
  evaluate-exp(|vars) = bottomup(debug(!97); try(evaluate-e(|vars)))

strategies
  extract: (l, r) -> (<extr> l, <extr> r)
  extract: Length(n, _) -> <extr> n
  extract: Int(f) -> <string-to-int> f
  extract: Float(f) -> <string-to-real> f
  extract: String(s, _) -> s
  extr-f: (l, r) -> (<extr-f> l, <extr-f> r)
  extr-f: f@Float(_) -> <extr> f
  extr-f: Int(f) -> <string-to-real> f
  
  construct-end-type: BinExpT(l, nT, _, _) -> <construct-end-type> (l, nT)
  construct-end-type: (LengthT(None(), u), nT) -> LengthT(nT, u)
  construct-end-type: (LengthT(l, u), nT) -> LengthT(<construct-end-type> (l, nT), u)
  
  extr = try(extract)

  apply-bin(|f) = extr; call(f||); try(intl-float)
  
  wrap-result: (IntT(),   v) -> Int(v)
  wrap-result: (FloatT(), v) -> Float(v)
  wrap-result: (LengthT(eT, u), v) -> Length(<wrap-result> (eT, v), u)
  wrap-result: (StringT(), v) -> String(v, DoubleQuote())
  
  op-to-f: (Add(), IntT()) -> "addi"
  op-to-f: (Sub(), IntT()) -> "subti"
  op-to-f: (Mul(), IntT()) -> "muli"
  op-to-f: (Mod(), IntT()) -> "modi"
  
  op-to-f: (Add(), FloatT()) -> "addr"
  op-to-f: (Sub(), FloatT()) -> "subtr"
  op-to-f: (Mul(), FloatT()) -> "mulr"
  op-to-f: (Div(), _)        -> "divr"
  op-to-f: (Mod(), FloatT()) -> "modr"
  
  op-to-f: (Add(), StringT()) -> "conc-strings"

  extr-math-type: LengthT(e, _) -> <try(extr-math-type)> e  
  extr-math-type: BinExpT(_, t, _, _) -> t
  extr-comp-v:    Length(e, _)  -> <try(extr-comp-v)> e

  

/**
 * Variable lookup
 */  
rules
  evaluate-e(|vars): VarRef(x) -> e with
    e := <get-value> (x, vars)


/** 
 * Logic
 */
rules
  evaluate-e(|vars): BinExp(And(), lhs, rhs) -> 
    <?(True(), True()) < !True() + !False()> (lhs, rhs)
  evaluate-e(|vars): BinExp(Or(), lhs, rhs) -> 
    <?(True(), _) < !True() + (?(_, True()) < !True() + !False())> (lhs, rhs)
  evaluate-e(|vars): UnExp(Not(), e) -> <?True() < !False() + !True()> e


/**
 * Comparison
 */
rules
  evaluate-e(|vars): BinExp(Eq(), lhs, rhs) -> // This might not be accurate for number comparisons
    <?(e, e) < !True() + !False()> (<strip-annos> lhs, <strip-annos> rhs)
  evaluate-e(|vars): BinExp(Gt(), lhs, rhs) ->  
    <extr-f; gtr < !True() + !False()> (lhs, rhs) 

  
/**
 * Math
 */
rules
  evaluate-e(|vars): e@BinExp(op, lhs, rhs) -> r with 
    // Get the expression result types
    a := <nabl2-get-ast-analysis>
    ; endT  := <nabl2-get-ast-type(|a)> e 
    ; wrapT := <try(construct-end-type)> endT
    
    // Extract the types for the math (sub)expressions,
    // e.g. LengthT(IntT(), _) -> IntT()
    ; compExpT  := <try(extr-math-type)> endT
    ; eLV := <try(extr-comp-v)> lhs
    ; eRV := <try(extr-comp-v)> rhs
    
    // Coerce the expressions to the needed types.
    ; compLV := <coerce> (eLV, compExpT)
    ; compRV := <coerce> (eRV, compExpT)
    
    // Perform the calculation
    ; f   := <op-to-f> (op, compExpT)
    ; v   := <apply-bin(|f)> (compLV, compRV)
    ; r   := <wrap-result> (wrapT, v)
