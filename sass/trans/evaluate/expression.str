module evaluate/expression

imports
  nabl2/api
  nabl2shared

imports
  evaluate/evaluate
  evaluate/number
  src-gen/signatures/Expression-sig
  src-gen/signatures/String-sig
  desugar/expression/-
  analysis/sass
  
  evaluate/coerce
  evaluate/interpret/interpret

strategies
  evaluate-exp(|store) = bottomup(try(evaluate-e(|store)))

strategies
  extract: (l, r) -> (<extr> l, <extr> r)
  extract: Length(n, _) -> <extr> n
  extract: Int(f) -> <string-to-int> f
  extract: Float(f) -> <string-to-real> f
  extract: String(s, _) -> s
  extr-f: (l, r) -> (<extr-f> l, <extr-f> r)
  extr-f: f@Float(_) -> <extr> f
  extr-f: Int(f) -> <string-to-real> f
  
  construct-end-type: BinExpT(l, nT, _, _) -> <construct-end-type> (l, nT)
  construct-end-type: (LengthT(None(), u), nT) -> LengthT(nT, u)
  construct-end-type: (LengthT(l, u), nT) -> LengthT(<construct-end-type> (l, nT), u)
  
  extr = try(extract)

  apply-bin(|f) = extr; call(f||); try(intl-float)
  
  wrap-result: (IntT(),   v) -> Int(v)
  wrap-result: (FloatT(), v) -> Float(v)
  wrap-result: (LengthT(eT, u), v) -> Length(<wrap-result> (eT, v), u)
  wrap-result: (StringT(), v) -> String(v, DoubleQuote())
  
  op-to-f: (Add(), IntT()) -> "addi"
  op-to-f: (Sub(), IntT()) -> "subti"
  op-to-f: (Mul(), IntT()) -> "muli"
  op-to-f: (Mod(), IntT()) -> "modi"
  
  op-to-f: (Add(), FloatT()) -> "addr"
  op-to-f: (Sub(), FloatT()) -> "subtr"
  op-to-f: (Mul(), FloatT()) -> "mulr"
  op-to-f: (Div(), _)        -> "divr"
  op-to-f: (Mod(), FloatT()) -> "modr"
  
  op-to-f: (Add(), StringT()) -> "conc-strings"

  extr-math-type: LengthT(e, _) -> <try(extr-math-type)> e  
  extr-math-type: BinExpT(_, t, _, _) -> t
  extr-comp-v:    Length(e, _)  -> <try(extr-comp-v)> e



/**
 * 
 */
strategies
  truthy = not(?False() <+ ?Null())

/**
 * Variable lookup
 */  
rules
  evaluate-e(|store): VarRef(x) -> e with
    e := <get-var(|store)> x


/** 
 * Logic
 */
rules
  evaluate-e(|store): BinExp(And(), lhs, rhs) -> True() where
    <truthy> lhs
    ; <truthy> rhs
  evaluate-e(|store): BinExp(And(), lhs, rhs) -> False()
  evaluate-e(|store): BinExp(Or(), lhs, rhs) -> False() where
    <not(truthy)> lhs
    ; <not(truthy)> rhs
  evaluate-e(|store): BinExp(Or(), lhs, rhs) -> True()
  evaluate-e(|store): UnExp(Not(), e) -> <truthy < !False() + !True()> e


/**
 * Comparison
 */
rules
  evaluate-e(|store): BinExp(Eq(), lhs, rhs) -> // This might not be accurate for number comparisons
    <?(e, e) < !True() + !False()> (<strip-annos> lhs, <strip-annos> rhs)
  evaluate-e(|store): BinExp(Gt(), lhs, rhs) ->  
    <extr-f; gtr < !True() + !False()> (lhs, rhs) 

  
/**
 * Math
 */
rules
//  evaluate-e(|store): e@BinExp(op, lhs, rhs) -> r with 
//    // Get the expression result types
//    a := <nabl2-get-ast-analysis>
//    ; endT  := <nabl2-get-ast-type(|a)> e 
//    ; wrapT := <try(construct-end-type)> endT
//    
//    // Extract the types for the math (sub)expressions,
//    // e.g. LengthT(IntT(), _) -> IntT()
//    ; compExpT  := <try(extr-math-type)> endT
//    ; eLV := <try(extr-comp-v)> lhs
//    ; eRV := <try(extr-comp-v)> rhs
//    
//    // Coerce the expressions to the needed types.
//    ; compLV := <coerce> (eLV, compExpT)
//    ; compRV := <coerce> (eRV, compExpT)
//    
//    // Perform the calculation
//    ; f   := <op-to-f> (op, compExpT)
//    ; f'  := <op-to-f> (op, compLV, compRV)
//    ; v   := <apply-bin(|f)> (compLV, compRV)
//    ; r   := <wrap-result> (wrapT, v)

strategies
  
  exp-t: Int(_) -> IntT()
  exp-t: Float(_) -> FloatT()
  exp-t: Length(n, u) -> LengthT(<exp-t> n, u)
  
  normalize-type-tuple: (op, l, FloatT()) -> (op, FloatT(), l)
  normalize-type-tuple: (op, l, StringT()) -> (op, StringT(), l)
  normalize-type-tuple: (op, l, r) -> (op, r, l) where
    <is-subterm> (FloatT(), r)
  op-to-f: (Add(), IntT(), IntT())  -> "addi"
  op-to-f: (Add(), FloatT(), _)     -> "addr"
  op-to-f: (Sub(), IntT(), IntT())  -> "subti"
  op-to-f: (Sub(), FloatT(), _)     -> "subtr"
  op-to-f: (Mul(), IntT(), IntT())  -> "muli"
  op-to-f: (Mul(), FloatT(), _)     -> "mulr"
  op-to-f: (Div(), _, _)            -> "divr"
  op-to-f: (Mod(), IntT(), IntT())  -> "modi"
  op-to-f: (Mod(), FloatT(), _)     -> "modr"
  op-to-f: (Add(), StringT(), StringT()) -> "conc-strings"
  
  /**
   * Addition
   */
  construct-end-type: (Add(), IntT(), IntT())     -> IntT()
  construct-end-type: (Add(), FloatT(), FloatT()) -> FloatT()
  construct-end-type: (Add(), FloatT(), IntT())   -> FloatT()
  construct-end-type: (Add(), StringT(), _)       -> StringT()
  construct-end-type: (Add(), LengthT(lnt, _), LengthT(rnt, u))
    -> LengthT(<construct-end-type> (Add(), lnt, rnt), u)
  
  
  construct-end-type: (Sub(), IntT(), IntT())     -> IntT()
  construct-end-type: (Sub(), FloatT(), _)        -> FloatT()
  construct-end-type: (Sub(), LengthT(lnt, _), LengthT(rnt, u))
    -> LengthT(<construct-end-type> (Sub(), lnt, rnt), u)
  
  construct-end-type: (Mul(), IntT(), IntT())     -> IntT()
  construct-end-type: (Mul(), FloatT(), _)        -> FloatT()
  
  construct-end-type: (Div(), IntT(), IntT())     -> FloatT()
  construct-end-type: (Div(), FloatT(), _)        -> FloatT()
  
  construct-end-type: (Mod(), IntT(), IntT())     -> IntT()
  construct-end-type: (Mod(), FloatT(), _)        -> FloatT()
  
  equalize-args: (Int(lhs), Float(rhs)) -> (Float(lhs), Float(rhs))
  equalize-args: (Float(lhs), Int(rhs)) -> (Float(lhs), Float(rhs))
     
rules
  evaluate-e(|store): BinExp(op, lhs, rhs) -> v with
    lT := <exp-t> lhs
    ; rT := <exp-t> rhs
    
    ; lCV := <try(extr-comp-v)> lhs
    ; rCV := <try(extr-comp-v)> rhs
    
    ; lCT := <try(extr-math-type)> lT
    ; rCT := <try(extr-math-type)> rT
    ; f := <try(normalize-type-tuple); op-to-f> (op, lCT, rCT)
     
    ; wrapT := <try(normalize-type-tuple); construct-end-type> (op, lT, rT)
       
    ; (lV, rV) := <try(equalize-args)> (lCV, rCV)
    ; numV := <apply-bin(|f)> (lV, rV)
    ; v := <wrap-result> (wrapT, numV)
